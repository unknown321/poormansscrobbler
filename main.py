#!/usr/bin/python
import os
import time
import struct
import sqlite3
import errno
import md5
import ConfigParser

API_KEY = "105ecba38f955654e6f9c8dd807af8fc"
SESSION_KEY = u""
SECRET = "c1b0073b739fe9d88f3f83ffd8349a10"
ROOT_URL ="https://ws.audioscrobbler.com/2.0/"		#You must use HTTPS for this request

COUNTS_PATH = 'PlayCounts'		# it should be 'Play Counts'
DB_PATH = 'Library.itdb'
LOCAL_DB_PATH = 'db.sqlite3'
CONFIG_PATH = 'config.cfg'

def get_credentials():
	config = ConfigParser.RawConfigParser()
	config.read(CONFIG_PATH)
	u = config.get('lastfm', 'username')
	p = config.get('lastfm', 'password')
	return {'username':u, 'password':p}

# these fieldnames are ignored when generating signature for song
IGNORED_FIELDNAMES = ['pid','playcount']

class Song(object):
	"""docstring for Song"""
	def __init__(self, _pid, _artist, _album, _title, _playcount, _timestamp):
		super(Song, self).__init__()
		self.api_sig = None
		self.method = None
		self.api_key = API_KEY
		self.pid = _pid
		self.artist = _artist
		self.album = _album
		self.track = _title 			# track title is 'track' for lastfm
		self.playcount = _playcount
		self.timestamp = _timestamp
		self.sk = SESSION_KEY
		self.generate_signature()

	def generate_signature(self, _method='track.scrobble'):
		# artist[i] (Required) : The artist name.
		# track[i] (Required) : The track name.
		# timestamp[i] (Required) : The time the track started playing,
		# api_key (Required) : A Last.fm API key.
		# api_sig (Required) : A Last.fm method signature. See authentication for more information.
		# sk (Required) : A session key generated by authenticating a user via the authentication protocol. 
		if not self.timestamp:
			return 0
		sig_string = u""
		self.api_sig = None
		self.method = _method
		self.timestamp = str(self.timestamp)
		for key, value in sorted(self.__dict__.items()):
			if key not in IGNORED_FIELDNAMES:
				if value:
					sig_string = sig_string + key + value
		self.method = None
		self.timestamp = int(self.timestamp)
		self.api_sig = md5.md5((sig_string+SECRET).encode('utf-8')).hexdigest()
		return 0

	def scrobble(self, method='track.scrobble'):
		self.method = 'track.scrobble'
		p = {}
		p['api_key'] = API_KEY
		for key, value in self.__dict__.items():
			if value:
				p[key] = value
		response = requests.post(ROOT_URL, params=p)
		self.method = None
		return response


class Bunch(object):
	"""a bunch of songs, 50 max"""
	def __init__(self, songs, start_timestamp):
		self.__songs__ = songs
		for s in self.__songs__:
			s['timestamp'] = start_timestamp
			start_timestamp+=1
		self.__generate_signature__()

	def __len__(self):
		return len(self.__songs__)

	def __generate_signature__(self):
		query_string = u""
		p = {}
		p['method'] = u'track.scrobble'
		p['api_key'] = API_KEY
		p['sk'] = u"b7b81208af657607db074021e3d3c947"
		for s in self.__songs__:
			i = str(self.__songs__.index(s))
			p['artist[{}]'.format(i)] = s['artist']
			p['track[{}]'.format(i)] = s['track']
			p['timestamp[{}]'.format(i)] = str(s['timestamp'])
			if s.has_key('album'):
				p['album[{}]'.format(i)] = s['album']
		for key, value in sorted(p.items()):
			query_string = query_string + key + value
		query_string = query_string + SECRET
		p['api_sig'] = u""
		p['api_sig'] = md5.md5((query_string).encode('utf-8')).hexdigest()
		p['query_string'] = query_string
		self.params = p

	def scrobble(self):
		del self.params['query_string']
		response = requests.post(ROOT_URL, params=self.params)
		self.method = None
		return response


class LocalDB(object):
	"""docstring for LocalDB"""
	def __init__(self, arg):
		super(LocalDB, self).__init__()
		self.arg = arg

	def create():
		if not check_path(LOCAL_DB_PATH):
			conn = sqlite3.connect(LOCAL_DB_PATH)
			c = conn.cursor()
			conn.close()

	def update_song(song):
		# updates a single song
		# songs removed from iPod should remain in database - they still exist in iTunes
		pass

	def add_song(song):
		pass

def authenticate(username,password):
	api_sig = md5.md5("api_key"+API_KEY
		+"method"+"auth.getMobileSession"
		+"password"+password
		+"username"+username
		+SECRET).hexdigest()
	p = {"method":"auth.getMobileSession",
		 "api_key":API_KEY,
		 "username": username,
		 "password":password,
		 "api_sig":api_sig}
	t = requests.post(ROOT_URL, data=p)
	tree = ElementTree.fromstring(t.text)
	key = tree.findall('session/key')
	if key:
		key = key[0].text
	return key

def check_path(path):
	return os.path.isfile(path)

def get_counts(path):
	counts = []
	file_size = os.path.getsize(path)
	# first record starts from 96 byte
	# 60 + 36 = 96
	# never use tell(), it lies a lot
	# http://stackoverflow.com/questions/19730875/python-file-tell-gives-wrong-value-location
	pos = 60
	with open(path,'r') as f:
		f.seek(pos)
		while True:
			pos = pos+36
			if pos+4 > file_size:
				break
			else:
				f.seek(pos)
				a = f.read(4)
				i = struct.unpack('<I',a)
				pos = pos + 4
				counts.extend(i)
	return counts

def get_selected_songs(_dbpath, _songs_ids):
	# gets songs info with at least one playcount from library
	# there is no point in getting songs with zero playcounts
	conn = sqlite3.connect(_dbpath)
	c = conn.cursor()
	songs = []
	for i in _songs_ids:
		phys_order = i[0]
		play_count = i[1]
		c.execute('SELECT pid, artist, title, album FROM item WHERE physical_order == (?)', (str(phys_order),) )
		songs.append((c.fetchone(), play_count))
	conn.close()
	return songs

def get_songs_ids(_counts):
	# remove zeroes leaving only songs which were played
	ids = []
	for physical_order, playcount in enumerate(_counts):
		if playcount > 0:
			ids.append((physical_order,playcount))
	return ids

def scrobble_bulk():
	# scrobbles 50 tracks per once
	pass

def get_playcounts_diff():
	# creates diff between two playcount files AND LIBRARIES
	# returns changed/added songs with amount of scrobbles
	pass

def main():
	creds = get_credentials()
	# SESSION_KEY = authenticate(creds['username'], creds['password'])
	if not (check_path(COUNTS_PATH) and check_path(DB_PATH) and check_path(CONFIG_PATH)):
		raise OSError(os.strerror(errno.ENOENT))
	counts = get_counts(COUNTS_PATH)
	songs_ids = get_songs_ids(counts)
	songs = get_selected_songs(DB_PATH,songs_ids)
	count = 0
	for s in songs:
		print s
		count = count + s[1]
	print len(songs),'songs', count, 'plays'
	return 0

if __name__ == '__main__':
	main()
